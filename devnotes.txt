TODO (latest build):
    - Need to optimize selections, they just have too much performance impact.
    - Errors should be shown in a visual queue on bottom left of screen, they fade out after some time.
    - Simulation current speed indicator (top right?).
    - Need text box prompts for rename and switch/button re-label functions.
    - Wire tool. Idea for this is to use two additional boards for vertical and horizontal parts, wire drawn between two points (exclusive).
    - Improved format for save files, each file includes a notes section that is displayed in the board viewer at the top of a board.
    - Pressing R when cursor over tile rotates the tile, same for flip.
    - Additional tool to "toggle" a tile (holding shift will "interact" instead like switch between crossover/junction or set switch/button label).
    - Provide a warning to save changes before exit, loading, or making new board.

TODO (future release):
    - Gonna need additional tri-state (dashed color) and conflict (red color) wire states. These will save as unpowered wires.
    - During simulation, if conflicting states occur then pause and show an error (a setting will be available to turn this off).

Current and potential bugs:
    - Update time rolls over and not all objects reset.
    - Problem where file dialog conflicts with internal window state, seems to only be fixable with multithreading.
        * To reproduce, start program, have mouse on window near middle, open file, double click test01 file such that mouse still near middle of window, and voila the alignment is fucked (doesn't work every time).
        * After selecting file and mouse not on window, no problems at all. Already tried deleting window events so this isn't the problem.

Simulation algorithm version 1:
    - There is a set for each type of update that occurs (cosmetic, wire, switch, button, LED, and gate, implemented as hash sets).
    - When the state of an object changes, it is given a cosmetic and state update in the appropriate sets and updates adjacent tiles.
        * During board loading, do not update adjacent tiles.
    - At start of frame, we already know every object that has received an update and may change state.
    - Basic idea is to crawl along each wire and change the wire state (using depth-first traversal).
        * If a gate is found, updates to it are added/removed.
        * If a different state is found then new state is used from now on (when applicable) and errors are fixed.
    - In the background, we are constantly running cosmetic updates to keep the editor running.
    - When a transition to the next frame happens:
        1. Start by iterating through all of the gateUpdates.
            A. Check the new state of the gate (only off or on) based on current states of surrounding elements and save it, remove the update if state did not change.
            B. The new state is saved as a transitioning state and does not affect current gate state (for now).
        2. Iterate switchUpdates, buttonUpdates, and gateUpdates, traverse outputs along wires using depth-first search.
            A. First, the update to this object is removed (in the case of an active button, the update gets added back later).
            B. For DFS to work, every wire is given a timestamp of when it was last updated and this is used to check if the wire has been traversed.
                1. Note that an integer overflow is possible here at approximately four billion updates, if it happens then need to reset timestamps of ALL wires back to zero (big overhead but basically never happens).
            C. Positions of wires are kept track of as wire is traversed in case an error is made and we need to fix the previous wires.
            D. If a switch/button/gate is found and it outputs, then the state is checked for an error (note that if it is a gate, we cannot remove updates to it because then the gate state will not change).
                1. For a gate that inputs or an LED, it is saved for later instead.
        3. If wire updates remain that were not removed during traversal, need to update these (same steps as above). Similar thing for remaining LED updates.
        4. Update all of the endpoints (LEDs and gates). LEDs are updated by DFS traversal on connected LEDs that assumes LOW state and gates just receive a state update.
        5. Last step is to update all of the buttons that are transitioning to LOW and increment the current update time.
    - The first frame simulated after loading a board or making edits will have some performance impact but additional frame simulations should not.

Simulation algorithm version 2 (features tri-state and invalid state wires):
    