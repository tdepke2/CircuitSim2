Todo:
    - Gonna need additional tri-state (dashed color) and conflict (red color) wire states. These will save as unpowered wires.
    - During simulation, if conflicting states occur then pause and show an error (a setting will be available to turn this off).
    - May need to optimize copy/paste functionality so that middle tiles do not update adjacent tiles.
    - Need to optimize selections, they just have too much performance impact.
    - Gonna want a try-catch in simulator::fileOption to catch file I/O errors.
    
    - Sometimes there is a crash when saving new board (happens after loading one?), also exceptions not getting caught in sub try block.

Potential bugs to test:
    - Update time rolls over and not all objects reset.

Simulation algorithm version 1:
    - There is a set for each type of update that occurs (cosmetic, wire, switch, button, LED, and gate, implemented as hash sets).
    - When the state of an object changes, it is given a cosmetic and state update in the appropriate sets and updates adjacent tiles.
        * During board loading, do not update adjacent tiles.
    - At start of frame, we already know every object that has received an update and may change state.
    - Basic idea is to crawl along each wire and change the wire state (using depth-first traversal).
        * If a gate is found, updates to it are added/removed.
        * If a different state is found then new state is used from now on (when applicable) and errors are fixed.
    - In the background, we are constantly running cosmetic updates to keep the editor running.
    - When a transition to the next frame happens:
        1. Start by iterating through all of the gateUpdates.
            A. Check the new state of the gate (only off or on) based on current states of surrounding elements and save it, remove the update if state did not change.
            B. The new state is saved as a transitioning state and does not affect current gate state (for now).
        2. Iterate switchUpdates, buttonUpdates, and gateUpdates, traverse outputs along wires using depth-first search.
            A. First, the update to this object is removed (in the case of an active button, the update gets added back later).
            B. For DFS to work, every wire is given a timestamp of when it was last updated and this is used to check if the wire has been traversed.
                1. Note that an integer overflow is possible here at approximately four billion updates, if it happens then need to reset timestamps of ALL wires back to zero (big overhead but basically never happens).
            C. Positions of wires are kept track of as wire is traversed in case an error is made and we need to fix the previous wires.
            D. If a switch/button/gate is found and it outputs, then the state is checked for an error (note that if it is a gate, we cannot remove updates to it because then the gate state will not change).
                1. For a gate that inputs or an LED, it is saved for later instead.
        3. If wire updates remain that were not removed during traversal, need to update these (same steps as above). Similar thing for remaining LED updates.
        4. Update all of the endpoints (LEDs and gates). LEDs are updated by DFS traversal on connected LEDs that assumes LOW state and gates just receive a state update.
        5. Last step is to update all of the buttons that are transitioning to LOW and increment the current update time.
    - The first frame simulated after loading a board or making edits will have some performance impact but additional frame simulations should not.

Simulation algorithm version 2 (features tri-state and invalid state wires):
    