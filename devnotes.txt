Notes:
    - Gonna need additional tri-state (dashed color) and conflict (red color) wire states. These will save as unpowered wires.
    - During simulation, if conflicting states occur then pause and show an error (a setting will be available to turn this off).
    - Implement the original wire algorithm first (without the additional states) for backwards compatibility.

    - May need to optimize copy/paste functionality so that middle tiles do not update adjacent tiles.

Simulation algorithm version 1:
    - There is a set for each type of update that occurs (cosmetic, wire, switch, button, LED, and gate, implemented as hash sets).
    - When the state of an object changes, it is given a cosmetic and state update in the appropriate sets and updates adjacent tiles.
        * During board loading, do not update adjacent tiles.
    - At start of frame, we already know every object that has received an update and may change state.
    - Basic idea is to crawl along each wire and change the wire state (using breadth-first traversal).
        * If a gate is found, updates to it are added/removed.
        * If a different state is found then new state is used from now on (when applicable) and errors are fixed.
    - In the background, we are constantly running cosmetic updates to keep the editor running.
    - When a transition to the next frame happens:
        1. Start by iterating through all of the gateUpdates.
            A. Check the new state of the gate (only off or on) and save it, remove the update if state did not change.
        2. Iterate switchUpdates, buttonUpdates, and gateUpdates, traverse outputs along wires using depth-first search.
            A. First, the update to this object is removed (unless it is a button that is currently high).
            B. For DFS to work, every wire is given a timestamp of when it was last updated and this is used to check if the wire has been traversed.
                1. Note that an integer overflow is possible here at approximately four billion updates, if it happens then need to reset timestamps of ALL wires back to zero (big overhead but basically never happens).
            C. Positions of wires are kept track of as wire is traversed in case an error is made and we need to fix the previous wires.
            D. If an endpoint is found and it outputs, then the state is checked for an error and updates to the endpoint are removed from gateUpdates if it is a gate (switches/buttons have outputs on four sides).
                1. If the endpoint inputs instead, then it is saved for later.
            ------------------------ Removed (E. After all wires traversed in this path, check if original wire state changed. If it didn't then remove the last n endpoints from memory as these won't need updates.)
        3. If wire updates remain that were not removed during traversal, need to update these (same steps as above).
        4. When traversal done for all wires, send updates to the endpoints (should only be LEDs and gates).
            A. In the case of an LED, perform a recursive trace through connected LEDs if the state changed.
    - The first frame simulated after loading a board or making edits will have some performance impact but additional frame simulations should not.

Simulation algorithm version 2 (features tri-state and invalid state wires):
    